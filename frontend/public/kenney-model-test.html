<!DOCTYPE html>
<html>
<head>
    <title>Kenney Model Loading Test</title>
    <style>
        body { margin: 0; padding: 20px; font-family: monospace; }
        canvas { border: 1px solid #ccc; margin: 10px 0; }
        .status { padding: 10px; margin: 5px 0; border-radius: 5px; }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
        .info { background: #d1ecf1; color: #0c5460; }
    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
            "three/examples/jsm/": "https://unpkg.com/three@0.158.0/examples/jsm/"
        }
    }
    </script>
</head>
<body>
    <h1>ğŸ® Kenney Model Loading Test</h1>
    
    <div id="status" class="status info">æ­£åœ¨æ¸¬è©¦æ¨¡å‹è¼‰å…¥...</div>
    
    <h2>æ¸¬è©¦çµæœ</h2>
    <div id="results"></div>
    
    <canvas id="canvas" width="800" height="400"></canvas>
    
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
        
        // è¨­ç½®å ´æ™¯
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, 800/400, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas') });
        renderer.setSize(800, 400);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        
        // æ·»åŠ å…‰æº
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        
        const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
        scene.add(ambientLight);
        
        camera.position.set(0, 2, 5);
        camera.lookAt(0, 0, 0);
        
        // æ·»åŠ åœ°é¢
        const groundGeometry = new THREE.PlaneGeometry(10, 10);
        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x90EE90 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
        
        const loader = new GLTFLoader();
        const statusDiv = document.getElementById('status');
        const resultsDiv = document.getElementById('results');
        
        // æ¸¬è©¦è·¯å¾‘å’Œå°æ‡‰çš„ NPC
        const testModels = [
            {
                name: 'NPC-1 (é™¸åŸ¹ä¿®)',
                path: '/kenney-models/character-male-a.glb',
                position: [-2, 0, 0]
            },
            {
                name: 'NPC-2 (åŠ‰å®‡å²‘)', 
                path: '/kenney-models/character-female-b.glb',
                position: [0, 0, 0]
            },
            {
                name: 'NPC-3 (é™³åº­å®‰)',
                path: '/kenney-models/character-male-c.glb', 
                position: [2, 0, 0]
            }
        ];
        
        let loadedCount = 0;
        let failedCount = 0;
        
        testModels.forEach((model, index) => {
            const resultDiv = document.createElement('div');
            resultDiv.className = 'status info';
            resultDiv.innerHTML = `è¼‰å…¥ä¸­: ${model.name}...`;
            resultsDiv.appendChild(resultDiv);
            
            loader.load(
                model.path,
                function(gltf) {
                    // æˆåŠŸè¼‰å…¥
                    loadedCount++;
                    resultDiv.className = 'status success';
                    resultDiv.innerHTML = `âœ… ${model.name} è¼‰å…¥æˆåŠŸï¼å‹•ç•«æ•¸: ${gltf.animations.length}`;
                    
                    // æ·»åŠ åˆ°å ´æ™¯
                    const modelGroup = new THREE.Group();
                    modelGroup.add(gltf.scene);
                    modelGroup.position.set(...model.position);
                    modelGroup.scale.setScalar(1.5);
                    modelGroup.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    scene.add(modelGroup);
                    
                    // æ’­æ”¾å‹•ç•«
                    if (gltf.animations.length > 0) {
                        const mixer = new THREE.AnimationMixer(gltf.scene);
                        const action = mixer.clipAction(gltf.animations[0]);
                        action.play();
                        
                        // å‹•ç•«æ›´æ–°
                        function animate() {
                            mixer.update(0.016);
                            requestAnimationFrame(animate);
                        }
                        animate();
                    }
                    
                    updateStatus();
                },
                function(progress) {
                    console.log('Loading progress:', model.name, progress);
                },
                function(error) {
                    // è¼‰å…¥å¤±æ•—
                    failedCount++;
                    resultDiv.className = 'status error';
                    resultDiv.innerHTML = `âŒ ${model.name} è¼‰å…¥å¤±æ•—: ${error.message}`;
                    console.error('Loading error:', error);
                    
                    updateStatus();
                }
            );
        });
        
        function updateStatus() {
            const totalTests = testModels.length;
            const completedTests = loadedCount + failedCount;
            
            if (completedTests === totalTests) {
                if (failedCount === 0) {
                    statusDiv.className = 'status success';
                    statusDiv.innerHTML = `ğŸ‰ æ‰€æœ‰ ${totalTests} å€‹æ¨¡å‹è¼‰å…¥æˆåŠŸï¼`;
                } else if (loadedCount === 0) {
                    statusDiv.className = 'status error';
                    statusDiv.innerHTML = `âŒ æ‰€æœ‰ ${totalTests} å€‹æ¨¡å‹è¼‰å…¥å¤±æ•—ï¼`;
                } else {
                    statusDiv.className = 'status info';
                    statusDiv.innerHTML = `âš ï¸ ${loadedCount}/${totalTests} å€‹æ¨¡å‹è¼‰å…¥æˆåŠŸï¼Œ${failedCount} å€‹å¤±æ•—`;
                }
            }
        }
        
        // æ¸²æŸ“å¾ªç’°
        function render() {
            requestAnimationFrame(render);
            renderer.render(scene, camera);
        }
        render();
        
    </script>
</body>
</html>